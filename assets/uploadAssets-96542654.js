import{as as h,cJ as N,jY as es,aT as ts,mh as k,f6 as v,mi as D,dC as f,au as m,ay as u,cW as os,ge as rs,mj as as,dI as S,kC as ns,dJ as is,at as cs,kB as ls,bi as us}from"./index-8b5e7d9b.js";import{h as ps,N as ds,i as U,o as B,A as ms}from"./External-45f5ccd1.js";const g="upload-assets",w=()=>new Error;class fs extends h{constructor(){super(`${g}:unsupported`,"Layer does not support asset uploads.",w())}}class hs extends h{constructor(){super(`${g}:no-glb-support`,"Layer does not support glb.",w())}}let gs=class extends h{constructor(){super(`${g}:no-supported-source`,"No supported external source found",w())}},ws=class extends h{constructor(){super(`${g}:not-base-64`,"Expected gltf data in base64 format after conversion.",w())}},ys=class extends h{constructor(){super(`${g}:unable-to-prepare-options`,"Unable to prepare uploadAsset request options.",w())}};class $s extends h{constructor(t,s){super(`${g}:bad-response`,`Bad response. Uploaded ${t} items and received ${s} results.`,w())}}let bs=class extends h{constructor(t,s){super(`${g}-layer:upload-failed`,`Failed to upload mesh file ${t}. Error code: ${s?.code??"-1"}. Error message: ${s?.messages??"unknown"}`,w())}};class C extends h{constructor(t){super(`${g}-layer:unsupported-format`,`The service allowed us to upload an asset of FormatID ${t}, but it does not list it in its supported formats.`,w())}}let Ps=class extends h{constructor(){super(`${g}:convert3D-failed`,"convert3D failed.")}};const j={upload:{createFromFiles:.8,loadMesh:.2},uploadAssetBlobs:{prepareAssetItems:.9,uploadAssetItems:.1},uploadConvertibleSource:{uploadEditSource:.5,serviceAssetsToGlb:.5},uploadLocalMesh:{meshToAssetBlob:.5,uploadAssetBlobs:.5}};function y(e,t=o=>{},s){return new Ts(e,t,s)}class Ts{constructor(t,s=r=>{},o){if(this.onProgress=s,this.taskName=o,this._progressMap=new Map,this._startTime=void 0,this._timingsMap=new Map,typeof t=="number"){this._weights={};for(let r=0;r<t;r++){const a=r,n=1/t;this._weights[a]=n,this._progressMap.set(a,0)}}else this._weights=t;this.emitProgress()}emitProgress(){let t=0;for(const[s,o]of this._progressMap.entries())t+=o*this._weights[s];if(t===1&&N("enable-feature:esri-3dofl-upload-timings")){const s=Math.round(performance.now()-(this._startTime??0))/1e3;console.log(`${this.taskName} done in ${s} sec`);for(const[o,r]of this._timingsMap){const a=Math.round(r.end-r.start)/1e3,n=Math.round(a/s*100);console.log(this.taskName??"Task",{stepKey:o,stepTime:a,relativeTime:n})}}this.onProgress(t)}setProgress(t,s){if(this._progressMap.set(t,s),N("enable-feature:esri-3dofl-upload-timings")){const o=performance.now();this._startTime??(this._startTime=o);const r=es(this._timingsMap,t,()=>({start:o,end:0}));s===1&&(r.end=o)}this.emitProgress()}simulate(t,s){return O(o=>this.setProgress(t,o),s)}makeOnProgress(t){return s=>this.setProgress(t,s)}}function O(e=s=>{},t=Ms){const s=performance.now();e(0);const o=setInterval(()=>{const r=performance.now()-s,a=1-Math.exp(-r/t);e(a)},Fs);return ts(()=>{clearInterval(o),e(1)})}function As(e,t=vs){return k(D(e*q/t))}function xs(e,t=js){return k(D(e*q/t))}const vs=10,js=10,q=8e-6,Fs=v(50),Ms=v(1e3),L=1e6,_=20*L,Es=2e9,Is=3;async function Ns({data:e,name:t,description:s},o,r){let a=null;try{const n=f(o,"uploads"),i=f(n,"info"),{data:c}=await m(i,{query:{f:"json"},responseType:"json"});u(r);const l=os(o),d=c.maxUploadFileSize*L,$=l?Es:d,x=l?Math.min(_,d):_;if(e.size>$)throw new Error("Data too large");const G=f(n,"register"),{data:F}=await m(G,{query:{f:"json",itemName:_s(t),description:s},responseType:"json",method:"post"});if(u(r),!F.success)throw new Error("Registration failed");const{itemID:W}=F.item;a=f(n,W);const K=f(a,"uploadPart"),M=Math.ceil(e.size/x),b=new Array;for(let p=0;p<M;++p)b.push(e.slice(p*x,Math.min((p+1)*x,e.size)));const P=b.slice().reverse(),E=new Array,V=y(M,r?.onProgress,"uploadItem"),Y=async()=>{for(;P.length!==0;){const p=b.length-P.length,T=P.pop(),A=new FormData,X=V.simulate(p,As(T.size));try{const Z=T;A.append("f","json"),A.append("file",Z),A.append("partId",`${p}`);const{data:ss}=await m(K,{timeout:0,body:A,responseType:"json",method:"post"});if(u(r),!ss.success)throw new Error("Part upload failed")}finally{X.remove()}}};for(let p=0;p<Is&&P.length!==0;++p)E.push(Y());await Promise.all(E);const Q=f(a,"commit"),{data:I}=await m(Q,{query:{f:"json",parts:b.map((p,T)=>T).join(",")},responseType:"json",method:"post"});if(u(r),!I.success)throw new Error("Commit failed");return I.item}catch(n){if(a!=null){const i=f(a,"delete");await m(i,{query:{f:"json"},responseType:"json",method:"post"})}throw n}}function _s(e){return e.replaceAll("/","_").replaceAll("\\","_")}async function ne(e,t,s){const o=e.length;if(!o)return s?.onProgress?.(1),[];const r=y(o,s?.onProgress,"uploadAssets");return Promise.all(e.map((a,n)=>ks(a,t,{...s,onProgress:r.makeOnProgress(n)})))}async function ks(e,{layer:t,ongoingUploads:s},o){const r=s.get(e);if(r)return r;if(!Ys(t))throw new fs;if(Ds(e,t))return o?.onProgress?.(1),e;const a=Ss(e,t,o);s.set(e,a);try{await a}finally{s.delete(e)}return e}function Ds(e,t){const{parsedUrl:s}=t;return s!=null&&e.metadata.externalSources.some(o=>ps(o,s))}async function Ss(e,t,s){const{metadata:o}=e,{displaySource:r}=o,a=R(r?.source,t),n=!!a,i=o.externalSources.length>0,c=n?Us(a,t,s):i?Bs(e,t,s):Cs(e,t,s),l=await c;return u(s),e.addExternalSources([l]),e}async function Us(e,t,s){return{source:await z(e,t,s),original:!0}}async function Bs(e,t,s){const o=J(t),{externalSources:r}=e.metadata,a=qs(r,t);if(!a)throw new gs;const n=y(j.uploadConvertibleSource,s?.onProgress,"uploadConvertibleSource"),i=await z(a,t,{onProgress:n.makeOnProgress("uploadEditSource")});e.addExternalSources([{source:i,original:!0}]);const c=a.reduce((d,{asset:$})=>$ instanceof File?d+$.size:d,0),l=n.simulate("serviceAssetsToGlb",xs(c));try{return{source:await Ws(i,t,o)}}finally{l.remove()}}async function Cs(e,t,s){const o=y(j.uploadLocalMesh,s?.onProgress,"uploadLocalMesh"),r=Os(e,t,{...s,onProgress:o.makeOnProgress("meshToAssetBlob")});return{source:await H([r],t,{...s,onProgress:o.makeOnProgress("uploadAssetBlobs")}),extent:e.extent.clone(),original:!0}}async function Os(e,t,s){const o=J(t),r=await e.load(s),a=await r.toBinaryGLTF({ignoreLocalTransform:!0});u(s);const n=await a.buffer();return u(s),{blob:new Blob([n.data],{type:n.type}),assetName:`${rs()}.glb`,assetType:o}}function qs(e,t){for(const s of e){const o=R(s.source,t);if(o)return o}return null}function R(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:o}}=t,r=ms(e),a=new Array;let n=!1;for(let i=0;i<r.length;++i){const c=Ls(r[i],s);if(!c)return null;o.includes(c.assetType)&&(n=!0),a.push(c)}return n?a:null}function Ls(e,t){const s=ds(e,t);return s?{asset:e,assetType:s}:null}async function z(e,t,s){return H(e.map(o=>Rs(o,s)),t,s)}async function H(e,t,s){const o=y(j.uploadAssetBlobs,s?.onProgress,"uploadAssetBlobs"),r=await Hs(e,t,{...s,onProgress:o.makeOnProgress("prepareAssetItems")});u(s);const a=r.map(({item:i})=>i),{uploadResults:n}=await Js(a,t,{...s,onProgress:o.makeOnProgress("uploadAssetItems")});return u(s),e.map((i,c)=>Gs(r[c],n[c],t))}async function Rs(e,t){const{asset:s,assetType:o}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:o};const r=await s.toBlob(t);return u(t),{blob:r,assetName:s.assetName,assetType:o}}async function zs(e,t,s){const{blob:o,assetType:r,assetName:a}=e;let n=null;try{const i=await Ns({data:o,name:a},t.url,s);u(s),n={assetType:r,assetUploadId:i.itemID}}catch(i){cs(i),Qs().warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!n){const i=await ls(o);if(u(s),!i.isBase64)throw new ws;n={assetType:r,assetData:i.data}}if(!n)throw new ys;return{item:n,assetName:a}}function Hs(e,t,s){const o=y(e.length,s?.onProgress,"prepareAssetItems");return Promise.all(e.map(async(r,a)=>{const n=zs(await r,t,{...s,onProgress:o.makeOnProgress(a)});return u(s),n}))}async function Js(e,t,s){const o=O(s?.onProgress);try{const r=await m(f(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(u(s),r.data.uploadResults.length!==e.length)throw new $s(e.length,r.data.uploadResults.length);return r.data}finally{o.remove()}}function Gs(e,t,s){const{success:o}=t;if(!o){const{error:l}=t;throw new bs(e.assetName,l)}const{assetHash:r}=t,{assetName:a,item:{assetType:n}}=e,{infoFor3D:{supportedFormats:i}}=s,c=as(n,i);if(!c)throw new C(n);return new U(a,c,[new B(`${s.parsedUrl.path}/assets/${r}`,r)])}async function Ws(e,t,s){const o=e.map(({assetName:l,parts:d})=>({assetName:l,assetHash:d[0].partHash})),r=t.capabilities?.operations.supportsAsyncConvert3D,a={f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:s,async:r},n=f(t.parsedUrl.path,"convert3D");let i;try{i=(await(r?Vs:Ks)(n,{query:a,responseType:"json",timeout:0})).data}catch{throw new Ps}const{supportedFormats:c}=t.infoFor3D;return i.assets.map(l=>{const d=S(l.contentType,c);if(!d)throw new C(d);return new U(l.assetName,l.contentType,[new B(l.assetURL,l.assetHash)])})}function Ks(e,t){return m(e,t)}async function Vs(e,t){const s=(await m(e,t)).data.statusUrl;for(;;){const o=(await m(s,{query:{f:"json"},responseType:"json"})).data;switch(o.status){case"Completed":return m(o.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(o.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await ns(Xs)}}function Ys(e){return!!e.infoFor3D&&!!e.url}function J(e){const{infoFor3D:t}=e,s=S("model/gltf-binary",t.supportedFormats)??is("glb",t.supportedFormats);if(!s)throw new hs;return s}function Qs(){return us.getLogger("esri.layers.graphics.sources.support.uploadAssets")}const Xs=v(1e3);export{ne as uploadAssets};
