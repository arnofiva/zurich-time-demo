import{dW as P,g2 as Y,dZ as y,bS as _,dR as $,g3 as b,dT as u,g4 as v,g5 as z,av as p,dS as S}from"./index-5b8adf8e.js";import B from"./FeatureLayer-f16366de.js";import{I as G,y as E,w as N,b as j,u as k,v as V,l as g,d as Z,m as I}from"./utils-f2073bb3.js";import{r as q}from"./fetchService-096ab2cf.js";import{o as x}from"./jsonContext-2b28d6d2.js";import"./FeatureLayerBase-e07f2f14.js";import"./LayerFloorInfo-b494a401.js";import"./serviceCapabilitiesUtils-3ac061d0.js";import"./editsZScale-e3d24fbf.js";import"./queryZScale-c917a291.js";import"./FeatureSet-04b2b8c3.js";import"./APIKeyMixin-90b32f33.js";import"./EditBusLayer-b09fc428.js";import"./OrderedLayer-8532bad2.js";import"./FeatureTemplate-b7e0da9d.js";import"./FeatureType-a8ae05f2.js";import"./versionUtils-202bc3bf.js";import"./TopFeaturesQuery-a462936c.js";import"./requestPresets-c67896ae.js";const f="Feature Service",h="feature-layer-utils",C=`${h}-save`,H=`${h}-save-as`,m=`${h}-saveall`,d=`${h}-saveall-as`;function w(a){return{isValid:z(a)&&(a.type!=="feature"||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function L(a){const e=[],t=[];for(const{layer:s,layerJSON:l}of a)s.isTable?t.push(l):e.push(l);return{layers:e,tables:t}}function O(a){return L([a])}async function J(a,e){return/\/\d+\/?$/.test(a.url)?O(e[0]):R(e,a)}async function R(a,e){if(!e)return a.reverse(),L(a);const{layer:{url:t,customParameters:s,apiKey:l}}=a[0];let r=await e.fetchData("json");r?.layers!=null&&r?.tables!=null||(r=await Q(r,{url:t??"",customParameters:s,apiKey:l},a.map(o=>o.layer.layerId)));for(const o of a)M(o.layer,o.layerJSON,r);return r}async function Q(a,e,t){a||(a={}),a.layers||(a.layers=[]),a.tables||(a.tables=[]);const{url:s,customParameters:l,apiKey:r}=e,{serviceJSON:o,layersJSON:n}=await q(s,{customParameters:l,apiKey:r}),i=T(a.layers,o.layers,t),c=T(a.tables,o.tables,t);a.layers=i.itemResources,a.tables=c.itemResources;const F=[...i.added,...c.added],K=n?[...n.layers,...n.tables]:[];return await W(a,F,s,K),a}function T(a,e,t){const s=Y(a,e,(r,o)=>r.id===o.id);a=a.filter(r=>!s.removed.some(o=>o.id===r.id));const l=s.added.map(({id:r})=>({id:r}));return l.forEach(({id:r})=>{a.push({id:r})}),{itemResources:a,added:l.filter(({id:r})=>!t.includes(r))}}async function W(a,e,t,s){const l=e.map(({id:r})=>new B({url:t,layerId:r,sourceJSON:s.find(({id:o})=>o===r)}));await Promise.allSettled(l.map(r=>r.load())),l.forEach(r=>{const{layerId:o,loaded:n,defaultPopupTemplate:i}=r;!n||i==null||M(r,{id:o,popupInfo:i.toJSON()},a)})}function M(a,e,t){a.isTable?A(t.tables,e):A(t.layers,e)}function A(a,e){const t=a.findIndex(({id:s})=>s===e.id);t===-1?a.push(e):a[t]=e}function D(a,e){if(!a.length)throw new p(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(a,e){const t=a.map(s=>s.portalItem.id);if(new Set(t).size>1)throw new p(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(a,e){const t=a.map(s=>s.layerId);if(new Set(t).size!==t.length)throw new p(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function aa(a){D(a,m),await Promise.all(a.map(e=>e.load()));for(const e of a)g(e,m,w),Z({layer:e,itemType:f,errorNamePrefix:m});X(a,m),U(a,m)}async function ea(a,e){const{url:t,layerId:s,title:l,fullExtent:r,isTable:o}=a,n=y(t);e.url=n?.serverType==="FeatureServer"?t:`${t}/${s}`,e.title||(e.title=l),e.extent=null,o||r==null||(e.extent=await $(r)),b(e,u.METADATA),b(e,u.MULTI_LAYER),S(e,u.SINGLE_LAYER),o&&S(e,u.TABLE)}function ta(a,e){for(const r of a){const o=r.parsedUrl.path,n=y(o);if(!n?.url.path)throw new p(`${e}:invalid-parameters`,I(r,`has unsupported url pattern: ${o}`),{layer:r});const c=n?.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new p(`${e}:invalid-parameters`,I(r,`has unsupported server type: ${c}`),{layer:r});if(c==="MapServer"&&a.length>1)throw new p(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=y(a[0].parsedUrl.path),s=t?.url.path;if(!a.every(r=>y(r.parsedUrl.path)?.url.path===s))throw new p(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ra(a){D(a,d),await Promise.all(a.map(e=>e.load()));for(const e of a)g(e,d,w);ta(a,d),U(a,d)}async function sa(a,e){let t=0,s=0;for(const{isTable:o}of e)o?s++:t++;const l=e[0].parsedUrl.path,r=y(l);if(a.url=r?.serverType==="FeatureServer"?r.url.path:l,a.title||(a.title=r.title),a.extent=null,t>0){const o=e.map(n=>n.fullExtent).filter(_).reduce((n,i)=>n.clone().union(i));o&&(a.extent=await $(o))}b(a,u.METADATA),v(a,u.MULTI_LAYER,e.length>1),v(a,u.SINGLE_LAYER,e.length===1),v(a,u.TABLE,s>0&&t===0),N(a)}async function Pa(a,e){return G({layer:a,itemType:f,validateLayer:w,createItemData:(t,s)=>J(s,[t]),errorNamePrefix:C},e)}async function $a(a,e){await aa(a);const t=a[0].portalItem,s=x(t),l=await Promise.all(a.map(o=>E(o,s,e))),r=await J(t,a.map((o,n)=>({layer:o,layerJSON:l[n]})));return N(t),await t.update({data:r}),await Promise.all(a.slice(1).map(o=>o.portalItem.reload())),P(s),t.clone()}async function Ea(a,e,t){return j({layer:a,itemType:f,validateLayer:w,createItemData:(s,l)=>Promise.resolve(O(s)),errorNamePrefix:H,newItem:e,setItemProperties:ea},t)}async function Na(a,e,t){await ra(a);const s=k({itemType:f,errorNamePrefix:d,newItem:e}),l=x(s),r=await Promise.all(a.map(n=>E(n,l,t))),o=await R(a.map((n,i)=>({layer:n,layerJSON:r[i]})));await sa(s,a),await V(s,o,t);for(const n of a)n.portalItem=s.clone();return P(l),s}export{Pa as save,$a as saveAll,Na as saveAllAs,Ea as saveAs};
