import{g2 as A,g3 as Y,cj as f,dO as _,g4 as P,g5 as b,g6 as p,g7 as v,g8 as j,as as u,g9 as I}from"./index-8b5e7d9b.js";import z from"./FeatureLayer-72a3b1cd.js";import{I as B,y as $,w as E,b as G,u as k,v as V,l as N,d as q,m as S}from"./utils-118e07d9.js";import{r as C}from"./fetchService-1b5d4dbf.js";import{o as x}from"./jsonContext-7dfdc657.js";import"./UniqueValueRenderer-176db886.js";import"./ColorStop-ac9a118d.js";import"./diffUtils-3ed1f592.js";import"./colorRamps-cf6fa9ce.js";import"./jsonUtils-3d6448c4.js";import"./DictionaryLoader-1a1ab2cc.js";import"./FieldsIndex-85e142d0.js";import"./heatmapUtils-3c0e0ece.js";import"./FeatureLayerBase-56c03a7a.js";import"./commonProperties-60f31277.js";import"./ElevationInfo-36952bdf.js";import"./featureLayerUtils-d891b150.js";import"./featureQueryAll-778379dd.js";import"./Query-630c5d65.js";import"./AttachmentQuery-ac66f9a7.js";import"./RelationshipQuery-249800df.js";import"./LayerFloorInfo-5c97dc41.js";import"./serviceCapabilitiesUtils-1513785a.js";import"./editsZScale-03b9f186.js";import"./queryZScale-9dee68ff.js";import"./FeatureSet-05a1ff98.js";import"./APIKeyMixin-9d7343aa.js";import"./ArcGISService-1771a240.js";import"./BlendLayer-dce91235.js";import"./jsonUtils-16d33138.js";import"./CustomParametersMixin-45f14a7d.js";import"./EditBusLayer-3babd061.js";import"./FeatureEffectLayer-50d5188d.js";import"./FeatureEffect-40ff6b77.js";import"./FeatureFilter-5ab88729.js";import"./FeatureReductionLayer-826e078c.js";import"./FeatureReductionSelection-4ea33fb1.js";import"./LabelClass-06cdad9c.js";import"./defaults-4b2d7493.js";import"./defaultsJSON-59981e75.js";import"./MD5-715f37cd.js";import"./OperationalLayer-5c10068f.js";import"./OrderedLayer-b68b3bb4.js";import"./PortalLayer-c3739096.js";import"./ScaleRangeLayer-5b526f5a.js";import"./TemporalLayer-683091de.js";import"./FeatureTemplate-0e5c0008.js";import"./FeatureType-347e5e8f.js";import"./fieldProperties-49b9eb67.js";import"./labelingInfo-4784a348.js";import"./versionUtils-e8eeb271.js";import"./styleUtils-f17e2eb8.js";import"./TopFeaturesQuery-268791e0.js";import"./popupUtils-6f3d55df.js";import"./requestPresets-f7ad0d2f.js";const d="Feature Service",h="feature-layer-utils",H=`${h}-save`,Q=`${h}-save-as`,c=`${h}-saveall`,y=`${h}-saveall-as`;function w(t){return{isValid:j(t)&&(t.type!=="feature"||!t.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function L(t){const r=[],a=[];for(const{layer:o,layerJSON:s}of t)o.isTable?a.push(s):r.push(s);return{layers:r,tables:a}}function O(t){return L([t])}async function J(t,r){return/\/\d+\/?$/.test(t.url)?O(r[0]):M(r,t)}async function M(t,r){if(!r)return t.reverse(),L(t);const{layer:{url:a,customParameters:o,apiKey:s}}=t[0];let e=await r.fetchData("json");e?.layers!=null&&e?.tables!=null||(e=await Z(e,{url:a??"",customParameters:o,apiKey:s},t.map(i=>i.layer.layerId)));for(const i of t)R(i.layer,i.layerJSON,e);return e}async function Z(t,r,a){t||(t={}),t.layers||(t.layers=[]),t.tables||(t.tables=[]);const{url:o,customParameters:s,apiKey:e}=r,{serviceJSON:i,layersJSON:l}=await C(o,{customParameters:s,apiKey:e}),n=T(t.layers,i.layers,a),m=T(t.tables,i.tables,a);t.layers=n.itemResources,t.tables=m.itemResources;const F=[...n.added,...m.added],K=l?[...l.layers,...l.tables]:[];return await W(t,F,o,K),t}function T(t,r,a){const o=Y(t,r,(e,i)=>e.id===i.id);t=t.filter(e=>!o.removed.some(i=>i.id===e.id));const s=o.added.map(({id:e})=>({id:e}));return s.forEach(({id:e})=>{t.push({id:e})}),{itemResources:t,added:s.filter(({id:e})=>!a.includes(e))}}async function W(t,r,a,o){const s=r.map(({id:e})=>new z({url:a,layerId:e,sourceJSON:o.find(({id:i})=>i===e)}));await Promise.allSettled(s.map(e=>e.load())),s.forEach(e=>{const{layerId:i,loaded:l,defaultPopupTemplate:n}=e;!l||n==null||R(e,{id:i,popupInfo:n.toJSON()},t)})}function R(t,r,a){t.isTable?g(a.tables,r):g(a.layers,r)}function g(t,r){const a=t.findIndex(({id:o})=>o===r.id);a===-1?t.push(r):t[a]=r}function D(t,r){if(!t.length)throw new u(`${r}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(t,r){const a=t.map(o=>o.portalItem.id);if(new Set(a).size>1)throw new u(`${r}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(t,r){const a=t.map(o=>o.layerId);if(new Set(a).size!==a.length)throw new u(`${r}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function tt(t){D(t,c),await Promise.all(t.map(r=>r.load()));for(const r of t)N(r,c,w),q({layer:r,itemType:d,errorNamePrefix:c});X(t,c),U(t,c)}async function rt(t,r){const{url:a,layerId:o,title:s,fullExtent:e,isTable:i}=t,l=f(a);r.url=l?.serverType==="FeatureServer"?a:`${a}/${o}`,r.title||(r.title=s),r.extent=null,i||e==null||(r.extent=await P(e)),b(r,p.METADATA),b(r,p.MULTI_LAYER),I(r,p.SINGLE_LAYER),i&&I(r,p.TABLE)}function at(t,r){for(const e of t){const i=e.parsedUrl.path,l=f(i);if(!l?.url.path)throw new u(`${r}:invalid-parameters`,S(e,`has unsupported url pattern: ${i}`),{layer:e});const m=l?.serverType;if(m!=="FeatureServer"&&m!=="MapServer")throw new u(`${r}:invalid-parameters`,S(e,`has unsupported server type: ${m}`),{layer:e});if(m==="MapServer"&&t.length>1)throw new u(`${r}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=f(t[0].parsedUrl.path),o=a?.url.path;if(!t.every(e=>f(e.parsedUrl.path)?.url.path===o))throw new u(`${r}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function et(t){D(t,y),await Promise.all(t.map(r=>r.load()));for(const r of t)N(r,y,w);at(t,y),U(t,y)}async function ot(t,r){let a=0,o=0;for(const{isTable:i}of r)i?o++:a++;const s=r[0].parsedUrl.path,e=f(s);if(t.url=e?.serverType==="FeatureServer"?e.url.path:s,t.title||(t.title=e.title),t.extent=null,a>0){const i=r.map(l=>l.fullExtent).filter(_).reduce((l,n)=>l.clone().union(n));i&&(t.extent=await P(i))}b(t,p.METADATA),v(t,p.MULTI_LAYER,r.length>1),v(t,p.SINGLE_LAYER,r.length===1),v(t,p.TABLE,o>0&&a===0),E(t)}async function sr(t,r){return B({layer:t,itemType:d,validateLayer:w,createItemData:(a,o)=>J(o,[a]),errorNamePrefix:H},r)}async function lr(t,r){await tt(t);const a=t[0].portalItem,o=x(a),s=await Promise.all(t.map(i=>$(i,o,r))),e=await J(a,t.map((i,l)=>({layer:i,layerJSON:s[l]})));return E(a),await a.update({data:e}),await Promise.all(t.slice(1).map(i=>i.portalItem.reload())),A(o),a.clone()}async function nr(t,r,a){return G({layer:t,itemType:d,validateLayer:w,createItemData:(o,s)=>Promise.resolve(O(o)),errorNamePrefix:Q,newItem:r,setItemProperties:rt},a)}async function pr(t,r,a){await et(t);const o=k({itemType:d,errorNamePrefix:y,newItem:r}),s=x(o),e=await Promise.all(t.map(l=>$(l,s,a))),i=await M(t.map((l,n)=>({layer:l,layerJSON:e[n]})));await ot(o,t),await V(o,i,a);for(const l of t)l.portalItem=o.clone();return A(s),o}export{sr as save,lr as saveAll,pr as saveAllAs,nr as saveAs};
